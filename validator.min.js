//Author: Rogelio Prestol
//https://github.com/progelio/validator.js
var validator = function () { "use strict"; function f(n) { return document.querySelector(n) } function i(n, t) { return s(n.querySelectorAll(t)) } function r(n, t) { return n.split(t).filter(function (n) { return n != "" }) } function n(n, t) { var i = r(n.className, " "), u = r(t, " "); u.forEach(function (n) { i.filter(function (t) { return t == n }).length == 0 && i.push(n) }); n.className = i.join(" ") } function t(n, t) { var u = r(n.className, " "), i = [], f = r(t, " "); u.forEach(function (n) { f.filter(function (t) { return n == t }).length == 0 && i.push(n) }); n.className = i.join(" ") } function s(n) { return Array.prototype.slice.call(n) } function c(n, t, i, r) { var u, f, e; if (t = t == null ? "" : t, i = i || typeof t, n != "required" && t === "" && !validator.config.validateEmptyValues) return !0; if (n == "custom") return r(t); if (n == "maxlength") return t.length <= parseInt(r); if (n == "minlength") return t.length >= parseInt(r); if (n == "pattern") return new RegExp("^" + r + "$").test(t); if (n == "length") return t.length == parseInt(r); if (n == "not") return r.indexOf(t) == -1; if (n == "any") return r.indexOf(t) > -1; if (n == "min") switch (i) { case "integer": case "number": case "float": return parseFloat(t) >= parseFloat(r); case "date": return Date.parse(t) >= Date.parse(r); default: throw "Type is invalid."; }if (n == "max") switch (i) { case "integer": case "number": case "float": return parseFloat(t) <= parseFloat(r); case "date": return Date.parse(t) <= Date.parse(r); default: throw "Type is invalid."; }return n == "compare" ? r == t : n == "date" ? (u = r.test(t), !u) ? u : (f = new Date(t), f == "Invalid Date") ? !1 : (e = t.replace(r, "$2"), f.getDate() == parseInt(e)) : r.test(t) } function e(n, t) { var e = [], s = [], o, r, l = t.label || "", i, f, u; for (i in t) if (t.hasOwnProperty(i) && ["integer", "number", "float", "date"].indexOf(i) > -1) { o = i; break } for (i in t) t.hasOwnProperty(i) && (f = h[i], f) && (u = f.error, "regex" in f ? r = f.regex : (r = t[i], i == "pattern" || (i == "compare" ? r = arguments[2] : i == "any" || i == "not" || typeof r == "object" && (u = r.error || u, r = r.value))), o == "date" && n && n.toLocaleString && (n = n.toLocaleString().replace(",", "")), c(i, n, o, r) || (e.push(i), u = u.replace(/\{(0|label)\}/g, l).replace(/\{(1|value)\}/g, r).trim(), s.push(u))); if (e.length > 0) return { label: l, failed: e, errors: s } } function l(n, t) { var f = [], i, r, u; for (i in t) t.hasOwnProperty(i) && (r = t[i], r.label = r.label || i, u = e(n[i], r, n[r.compare]), u) && (u.name = i, f.push(u)); return f } function a(u) { if (arguments.length == 2) return l(arguments[0], arguments[1]); var o = typeof u == "string" ? f(u) : u, c = i(o, "input[rules], select[rules], textarea[rules]"), s = [], a = i(o, "*[rule-msg]"), h = i(o, "*[rules-summary]"); return a.forEach(function (n) { t(n, "validator-error"); t(n, validator.config.errorCss); n.$validator || (n.$validator = { template: n.innerHTML }) }), h.forEach(function (n) { t(n, "validator-summary"); t(n, validator.config.errorSummaryCss); n.innerHTML = "" }), c.forEach(function (f) { var l, v = ["checkbox", "radio"].indexOf(f.type) > -1 ? f.checked || "" : f.value, y = f.getAttribute("rules-label") || f.name || f.id, p = r(f.getAttribute("rules"), " "), c = { label: y }, h, a; p.forEach(function (n) { var f = n.split("="), t = f[0], r = f.slice(1).join("="), u; c[t] = r || !0; t == "custom" && (c.custom = validator.custom[r]); t == "compare" && (u = i(o, "#" + r)[0], u && (l = u.value)) }); f.$validator || (f.$validator = {}, f.addEventListener("blur", function () { validator.validate(u) })); h = e(v, c, l); t(f, "input-error"); t(f, validator.config.errorInputCss); h && (n(f, "input-error"), n(f, validator.config.errorInputCss), h.name = f.name, a = i(o, "*[rule-msg]"), a.forEach(function (t) { var i = t.getAttribute("rule-msg"); (i == f.name || i == h.failed[0] || i == f.name + "." + h.failed[0] || i == "") && (n(t, "validator-error"), n(t, validator.config.errorCss), t.innerHTML = t.$validator.template || h.errors[0], t.innerHTML = t.innerHTML.replace(/\{(0|label)\}/g, h.label)) }), s.push(h)) }), h.forEach(function (t) { n(t, "validator-summary"); n(t, validator.config.errorSummaryCss); var i = ""; s.forEach(function (n) { n.errors.length > 0 && (i += "<li>" + n.errors.join("<\/li><li>") + "<\/li>") }); t.innerHTML = "<ul>" + i + "<\/ul>" }), s.filter(function (n) { if (n.errors.length > 0) return n }) } var h = { required: { regex: /^.{1,}$/, error: "{0} is required." }, email: { regex: /^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/, error: "{0} is not an email address." }, number: { regex: /^-?\d+(.\d+)?/, error: "{0} is not a number." }, integer: { regex: /^-?\d+$/, error: "{0} is not an integer." }, float: { regex: /^-?\d+[.]\d+$/, error: "{0} is not a float." }, date: { regex: /^(\d{1,2})[/](\d{1,2})[/](\d{2}(\d{2})?)(\s\d{1,2}[:]\d{2}([:]\d{2})?\s(am|pm))?$/i, error: "{0} is not a date." }, ssn: { regex: /^\d{3}-\d{2}-\d{4}$/, error: "{0} is not a social security number." }, creditcard: { regex: /^\d{15,16}$/, error: "{0} is not a credit card number." }, maxlength: { error: "{0} must not exceed {1} characters." }, minlength: { error: "{0} must not be less than {1} characters." }, max: { error: "{0} must not be greater than {1}." }, min: { error: "{0} must not be less than {1}." }, length: { error: "{0} must be {1} characters long." }, url: { regex: /^(http(s)?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w-./?%&=]*)?(\?.*)?$/, error: "{0} is not a valid URL." }, pattern: { error: "{0} is not valid." }, zip: { regex: /^\d{5}(-\d{4})?$/, error: "{0} is not a valid postal code." }, phone: { regex: /^((\(\d{3}\)?)|(\d{3}-))?\d{3}-\d{4}$/, error: "{0} is not a valid phone." }, compare: { error: "{0} does not match." }, not: { error: "{0} is not allowed." }, any: { error: "{0} is not allowed." }, custom: { error: "{0} is invalid." } }, o = "validatorCss", u; return f(o) || (u = document.createElement("style"), u.id = o, u.type = "text/css", u.innerHTML = "*[rule-msg],*[rules-summary]{position:absolute;left:-8000px}.validator-error,.validator-summary{position:static;left:auto}", f("head").appendChild(u)), { config: { errorCss: "validator-error", errorInputCss: "input-error", errorSummaryCss: "validator-summary", validateEmptyValues: !1 }, custom: {}, validate: a, single: e } }();
